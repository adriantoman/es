#!/usr/bin/env ruby
# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
# have this method, so we add it so we get resolved symlinks
# and compatibility
unless File.respond_to? :realpath
  class File #:nodoc:
    def self.realpath path
      return realpath(File.readlink(path)) if symlink?(path)
      path
    end
  end
end
$: << File.expand_path(File.dirname(File.realpath(__FILE__)) + '/../lib')
require 'rubygems'
require 'gli'
require 'es_version'
require 'gooddata'
require 'pp'
require 'logger'
require 'es'
require 'date'
require 'chronic'
require 'fastercsv'

include GLI

PID       = ENV['PID']
ES_NAME   = ENV['ES_NAME']
LOGIN     = ENV['LOGIN']
PASSWORD  = ENV['PASSWORD']

program_desc 'ES generator - Should help you with working with Event Store'
version Es::VERSION

desc 'Turn on HTTP logger'
arg_name 'log'
switch [:l,:logger]

desc 'GD server'
arg_name 'server'
flag [:s,:server]

desc 'WEBDAV server'
arg_name 'webdav'
flag [:w,:webdav]


desc 'Creates ES'
command :create do |c|
  c.action do |global_options,options,args|
    Es::Commands::create({
      :pid        => PID,
      :es_name    => ES_NAME
    })
  end
end

desc 'Delete ES'
command :delete do |c|
  c.action do |global_options,options,args|
    Es::Commands::delete({
      :pid      => PID,
      :es_name  => ES_NAME
    })
  end
end


desc 'Show all types that are supported.'
command :types do |c|
  c.action do |global_options,options,args|
    Es::Commands::get_types.each {|t| puts t}
  end
end

desc 'Load data'
command :load do |c|
  c.desc 'Execute only for one entity.'
  c.default_value false
  c.flag [:o, :only]
  
  c.desc 'Print the task in the ugly oneliner mode for use in legacy tools. Does not run the actual extract.'
  c.default_value false
  c.switch [:j, :json]
  
  c.desc 'Verbose mode'
  c.default_value false
  c.switch [:v, :verbose]

  c.desc 'Base files directory. If specified it will ignore specific files and it will pick up all files in this directory with pattern load*.json'
  c.default_value nil
  c.flag [:b, :basedir]

  c.action do |global_options,options,args|
    options[:filenames] = args
    options[:pattern]   = "gen_load*.json"
    options[:pid]       = PID
    options[:es_name]   = ES_NAME
    Es::Commands::load(options)
  end
end

desc 'Load Deleted Records'
command :load_deleted do |c|

  c.desc 'Base files directory. If specified it will ignore specific files and it will pick up all files in this directory with pattern load*.json'
  c.default_value nil
  c.flag [:b, :basedir]
  
  c.desc 'Compatibility mode. If set to true deleted records will be loaded old style with type isDeleted. Otherwise deleted records will be loaded with type attribute and DeletedAt field will be added.'
  c.default_value false
  c.flag [:c, :compatibility]

  c.action do |global_options,options,args|
    options[:filenames] = args
    options[:pattern]   = "gen_load*.json"
    options[:pid]       = PID
    options[:es_name]   = ES_NAME
    Es::Commands::load_deleted(options)
  end
end

desc 'Extract'
command :extract do |c|
  
  c.desc 'Execute only for one entity.'
  c.default_value false
  c.flag [:o, :only]
  
  c.desc 'Verbose mode'
  c.default_value false
  c.switch [:v, :verbose]
  
  c.desc 'Print the task in the ugly oneliner mode for use in legacy tools. Does not run the actual extract.'
  c.default_value false
  c.switch [:j, :json]
  
  c.desc 'Run as usual but output the task definition in pretty print for debugging.'
  c.default_value true
  c.switch [:d, :debug]

  c.desc 'Base files directory. If specified it will ignore specific files and it will pick up all files in this directory with pattern load*.json'
  c.default_value nil
  c.flag [:b, :basedir]

  c.desc 'Extract files directory. If specified it will ignore specific files and it will pick up all files in this directory with pattern extract*.json'
  c.default_value nil
  c.flag [:e, :extractdir]


  c.action do |global_options,options,args|
    base_dir          = options[:basedir]
    extract_dir       = options[:extractdir]
    options[:pid]     = PID
    options[:es_name] = ES_NAME
    Es::Commands::extract(options)
  end
end

desc 'Generate extract config template'
command :generate_extract do |c|
  c.desc 'Base files directory. If specified it will ignore specific files and it will pick up all files in this directory with pattern load*.json'
  c.default_value nil
  c.flag [:b, :basedir]
  
  c.action do |global_options,options,args|
    base_dir = options[:basedir]
    fail "You need to specify base dir" if base_dir.nil?
    
    base_filenames = Dir::glob("#{base_dir}/gen_load_*.json")
    # build one giant load config
    base_entities = base_filenames.reduce([]) do |memo, filename|
      fail "File #{filename} cannot be found" unless File.exist?(filename)
      load_config = Es::Helpers.load_config(filename)
      load = Es::Load.parse(load_config)
      memo.concat(load.entities)
    end
    hyper_load = Es::Load.new(base_entities)
    entity_names = hyper_load.entities.map {|e| e.name}.uniq

    entity_names.each do |entity_name|
      entity = hyper_load.get_merged_entity_for(entity_name)
      
      File.open(base_dir+"/gen_extract_"+entity.name+".json", 'w') do |f|
          f.write JSON.pretty_generate(entity.to_extract_config)
      end
    end
    
  end
end

desc 'Generate base conifg template'
command :generate_base do |c|
  
  c.desc 'Name of the entity. If inputdir is also specified all generated base files will have this entity set. If you want to set entity for each file according to the file name do not provide this parameter.'
  c.default_value nil
  c.flag [:e, :entity]

  c.desc 'Input file.'
  c.default_value nil
  c.flag [:i, :input]
  
  c.desc 'Output filename. If not provided it print to STDOUT.'
  c.default_value nil
  c.flag [:o, :output]
  
  c.desc 'Input files directory. If specified it will ignore specific file and it will pick up all files in this directory with pattern *.csv'
  c.default_value nil
  c.flag [:s, :inputdir]

  c.desc 'Base files directory. If this and inputdir are specified base JSONs will be generated into the directory.'
  c.default_value nil
  c.flag [:b, :basedir]

  c.action do |global_options,options,args|
    entity = options[:entity]
    input_filename = options[:input]
    input_dir = options[:inputdir]
    output_filename = options[:output]
    base_dir = options[:basedir]

    fail "You need to specify input file name or input dir" if input_filename.nil? && input_dir.nil?

    if base_dir.nil?
      input_filenames = [input_filename]
    else
      input_filenames = Dir::glob("#{input_dir}/*.csv")
    end
       
    input_filenames.each do |input_filename|

      headers = nil
      FasterCSV.foreach(input_filename, :headers => true, :return_headers => true) do |row|
        if row.header_row?
          headers = row.fields
          break
        end
      end

      entity_name = entity || File.basename(input_filename, ".csv")
      load = Es::Load.new([
        Es::Entity.new(entity_name, {
          :file => input_filename,
          :fields => headers.map do |field_name|
            Es::Field.new(field_name, "none")
          end
        })
      ])

      config = JSON.pretty_generate(load.to_config)
      
      if input_dir && base_dir
        File.open(base_dir+"/gen_load_"+entity_name+".json", 'w') do |f|
          f.write config
        end
      elsif input_filename && output_filename
        File.open(output_filename, 'w') do |f|
          f.write config
        end
      else 
        puts config
      end
      
    end
  end
end

desc 'Truncate entity. Truncation means that you specify a time all events in that entit larger than the time will be thrown away.'
command :truncate do |c|
  
  c.desc 'Name of the entity.'
  c.default_value nil
  c.flag [:e, :entity]

  c.desc 'Timestamp in epoch to which the ES will be truncated.'
  c.default_value nil
  c.flag [:t, :timestamp]

  c.desc 'Base files directory. If specified it will ignore specific files and it will pick up all files in this directory with pattern load*.json'
  c.default_value nil
  c.flag [:b, :basedir]

  c.action do |global_options,options,args|
    options[:load_filenames]  = args
    options[:pid]             = PID
    options[:es_name]         = ES_NAME
    options[:basedir_pattern] = "gen_load*.json"
    Es::Commands.truncate(options)
  end
end

desc 'Initial load column'
command :load_column do |c|
  
  c.desc 'Verbose mode'
  c.default_value false
  c.switch [:v, :verbose]
  
  c.desc 'Run as usual but output the task definition in pretty print for debugging.'
  c.default_value true
  c.switch [:d, :debug]

  c.desc 'Name of the column.'
  c.default_value nil
  c.flag [:n, :name]

  c.desc 'Name of the entity.'
  c.default_value nil
  c.flag [:e, :entity]

  c.desc 'Type of the column.'
  c.default_value nil
  c.flag [:t, :type]

  c.desc 'Base config filename.'
  c.default_value nil
  c.flag [:b, :base]

  c.desc 'Input data filename.'
  c.default_value nil
  c.flag [:i, :input]

  c.action do |global_options,options,args|
    puts "EXPERIMENTAL FEATURE - BEWARE".color(:red)
    file = options[:input]
    name = options[:name]
    type = options[:type]
    entity = options[:entity]
    base_filename = options[:base]

    fail "You need to specify column name" if name.nil?
    fail "You need to specify column type" if type.nil?
    fail "You need to specify entity name" if entity.nil?
    fail "You need to specify input file name" if file.nil?

    base_config_file = Es::Helpers.load_config(base_filename)
    base = Es::Load.parse(base_config_file)

    load = Es::Load.new([
      Es::Entity.new(entity, {
        :file => file,
        :fields => [
          Es::Field.new('id', 'recordid'),
          Es::Field.new('timestamp', 'timestamp'),
          Es::Field.new(name, type)
        ]
      })
    ])

    base.get_entity(entity).add_field(Es::Field.new(name, type))
    puts "Added field #{field.name}" if options[:verbose]
    base.to_config_file(base_filename)
    
    load.entities.first.load(PID, ES_NAME)
  end
end

desc 'Shows more info about'
command :inspect do |c|

  c.action do |global_options,options,args|

    what = args.first
    filename = args[1]

    case what
    when "load"
      fail "Specify a file with base config" if filename.nil?
      base_config_file = Es::Helpers.load_config(filename)
      base = Es::Load.parse(base_config_file)
      base.entities.each do |entity|
        puts entity.to_table
      end
    end
  end
end


pre do |global,command,options,args|
  next true if command.nil?
  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  fail "PID env variable should be specified" if PID.nil? || PID.empty?
  fail "ES_NAME env variable should be specified" if ES_NAME.nil? || ES_NAME.empty?
  fail "LOGIN env variable should be specified" if LOGIN.nil? || LOGIN.empty?
  fail "PASSWORD env variable should be specified" if PASSWORD.nil? || PASSWORD.empty?

  GoodData.logger = Logger.new(STDOUT) if global[:logger]
  GD_SERVER = global[:server]
  GD_WEBDAV = global[:webdav]
  begin
    GoodData.connect LOGIN, PASSWORD, GD_SERVER, {
      :timeout       => 60,
      :webdav_server => GD_WEBDAV
    }
  rescue RestClient::BadRequest => e
    puts "Login Failed"
    exit 1
  end
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # pp exception.backtrace
  if exception.is_a?(SystemExit) && exception.status == 0
    false
  else
    # pp exception.inspect
    puts exception.message.color(:red)
    false
  end
  
  # Error logic here
  # return false to skip default error handling
  # false
  # true
end

exit GLI.run(ARGV)
